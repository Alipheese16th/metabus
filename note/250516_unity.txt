

% 유니티에서의 단위
길이의 1유닛 1미터
각도의 1유닛 1도
무게의 1유닛은? 그런거없다. 무게는 상대적으로만 계산


%
하이라키에서 오브젝트 더블클릭시 시점이동
씬뷰에서 원하는 오브젝트 선택후 F 시점이동
씬뷰에서 원하는 오브젝트 선택후 Shift + F 시점이동 및 고정



# 이제 무기 발사를 만들거임
총알을 하이라키뷰에 가져와서 트랜스폼 리셋 해보면 총알 방향이 수직으로 위를 향해있다
모델링 만들때 Y축 방향 (맥스에선 Y축이 앞방향임) 으로 만들었을텐데 유니티는 Y축이 up방향임

빈게임 오브젝트를 만들고 총알오브젝트를 자식객체로 집어넣는다. 총알객체를 원하는 방향으로 회전시켜도
빈게임오브젝트는 좌표가 원점이기때문에 회전문제가 안생김. 안정적임.

% 왼손좌표계 오른손좌표계

또한 크기도 너무크다. scale을 그냥 0.2로 줄여버리면 이것도 문제임. 원본은 그대로 1.0으로 불러오고 이걸 중간에 줄이는 작업을 해서 보여주는거임
model 인스텍퍼에서 scale Factor 값을 줄여야됨


# 충돌 처리 Collision / Trigger

충돌하는 순간 Enter
충돌하는 중 Stay
분리됨 Exit

## 충돌 영역 형태
- 구 : 면의 갯수 8개 (총알)
- 박스 : 면의 갯수 12개 (네모난 가구)
- 캡슐 : 면의 갯수 10개 (사람)

면의 갯수에 따라 성능차이가 있으니 최대한 효율적인 콜라이더를 적용하자
그러나 더 좋은 방법이 있다.
폴리곤 매쉬 형태 그대로 콜라이더를 만들수 있다

% 매쉬 콜라이더

매쉬콜라이더는 당연히 복잡한 폴리곤일수록 면의 양이 많아서 메모리를 많이 쓸수 있으나
간단한 매쉬는 오히려 더 성능이 좋을수도 있다.
예를들어 파티클 입자들은 쿼드 한장으로 만드는데 매쉬콜라이더 면2장으로 만들수있음
파티클 입자 하나하나 쿼드에 이미지를 씌워서 입자들을 충돌처리 한다든가 
불꽃놀이 or 연기 등

또한 매쉬콜라이더는 Convex 체크를 하면 면의 갯수가 확 줄어듬 (최대 255개). 체크를 안하면 매쉬 데이터 그대로 면갯수를 가져오기때문에 말도 안되게 많아짐.
그러나 convex도 만능은 아닌게 자체적인 알고리즘으로 처리하기때문에 원하지 않는 형태가 될수도있다. (예를들어 중간중간 빈공간을 그냥 뭉텅이로 처리한다든가)

또 하나의 방법은 로우폴리를 사용하는 것이다.
로우폴리모델을 하이폴레모델과 겹쳐놓고 로우폴리모델은 렌더링 하지않음. 로우폴리에 메시콜라이더를 적용한다.
이런식으로 처리해도됨. 로우폴리는 콜라이더만 처리하려고 쓸수도 있다는것.

콜라이더는 면적에 따라 마찰력의 차이가 날수 있음. 면적이 넓을수록 마찰력이 높고 면적이 좁을수록 마찰력이 낮음

자동차에 그냥 박스 콜라이더를 적용하면 마찰때문에 적용하기가 힘듬. (그렇다고 마찰력을 낮추면 너무 잘 미끄러짐)

% 휠 콜라이더 (자동차 바퀴에 적용하는 축 디스크 콜라이더)
- 휠 축 (구르는)
- 조향 축 (차량 방향을 회전하는)
- 충격흡수 (고무처럼 차체를 누르면 살짝 탄성있는)

그럼 복잡한 맵 지형은 ? 막 산맥들이 있다고 치면.. 이걸 다 매쉬콜라이더로 하기가 어마어마하다.
이럴때 쓰는게

% 터레인 콜라이더
단순한 평면은 폴리곤 갯수를 줄이고 복잡한 형태는 폴리곤 갯수가 많아짐
그래도 속도가 느릴수밖에없다 (몇년전만 해도 모바일에서 사용하기 힘들었음. 그러나 모바일 배그 출시하면서 터레인 기능을 사용함)

총 6가지의 콜라이더
구,박스,캡슐,매쉬,휠,터레인


# 강체 RigidBody

총알을 물리적으로 발사할것이기 때문에 리짓바디를 적용

## Mass 질량
기본값 1
무게는 상대적으로 계산되기때문에 개발자가 기준을 정해야함
총알이 원래 무게대로 주면 (현실처럼 속도가 빠르지 않기에) 충돌량이 대단히 약하다
사람이 1이면 0.2정도는 줘야 위력적으로 됨

## Drag 공기저항
기본값 0
높으면 물속에 있는거처럼 움직임

## Angular Drag 회전 저항값
기본값 0.05
회전 저항이 없으면 무한히 돈다

## Use Gravity 중력 저항

## is Kinematic
물리엔진에 영향을 안받음 (중력이나 충돌에 반응 안함)

## Interpolate 보간
- 보간 Interpolate 프레임과 프레임 사이의 위치를 계산
- 외삽 Extrapolate 위치와 속도를 계산해서 다음 위치를 미리 계산

## Collision Detection
- Discrete 그 순간 충돌
- Continuous 중간 충돌도 계산 (총알은 이걸로 사용해야함. 안그러면 계산 못하고 벽 뚫는 경우가 생김)

## Constraints
위치 또는 회전을 내가 원하는 축을 프리즈 할수있다.
예를들어 position Y 축을 Freeze 체크하면 위아래로는 이동안함

플레이어는 리짓바디에 캡슐콜라이더를 쓸건데 이동하다보면 넘어진다. 로테이션 전부 프리즈해주면됨


# 총구위치잡기

씬뷰에서 플레이어 시점 고정하고

기즈모 - 라이트뷰 - 아이소뷰
조명도 끄기

무기아래 빈오브젝트(FirePosition) 생성 후 리셋
위치 맞춰서 좌표 바꾸기 -0.1424/0.034/0.8731

그리고 플레이어에 스크립트 하나 추가하고
firePosition 에 맞춰서 총알생성
Instantiate(bullet, firePos.position, firePos.rotation);

총알은 생성됐을때 스크립트에 딱한번 물리연산함
void Start()
{
	GetComponent<Rigidbody>().AddForce(transform.forward * speed);
}

그래서 이제 총알 발사가된다.

그러나 총알이 잘 보이지 않는다

# Trail Renderer
어떤오브젝트의 움직임을 볼수 있는 잔상 효과 (폴리곤 면을 시간단위로 생성해내는것임)
그러나 면일텐데 왜 계속 어느 시점으로 보든 보일까? 입체가 아니라 쿼드 면 단위인데
이 기능을 빌보드라고 한다. 면이 계속 카메라를 향해 바라보고있음

- 그래프 : 꼬리의 두께를 곡선으로 나타낼수있음.
- Time : 사라지는 시간
- Min Vertex Distance : 폴리곤이 생기는 딜레이 시간. 클수록 폴리곤이 생기는 텀이 길어져서 잔상이 각이 진다
- Cast Shadows : 그림자 생성 규칙 (불꽃은 그림자 없다. 따라서 사격효과는 그림자 없음)
- Receive Shadows : 그림자 효과를 받는지 (내가 나무밑에 들어가면 어두워지는것처럼)


# 효과 매터리얼 적용하기

BulletTrail 매터리얼 하나 생성후에 스탠다드쉐이더를 쓸 필요가없다. 명암도 필요없다. 효과니까
Shader 를 Particles 로 해도 되겠지만 Mobile 의 Particles 가 더 가벼우니까 이걸로 해보자
Mobile/Particles/Additive 를 고르고 텍스쳐를 선택 Trail
파티클 쉐이더에서 검은색은 투명이다 (검은배경)

# 총알 벽에 부딪히면 사라지게 하기
총알에서 스크립트 구현하는거보다 부딪히는 쪽에서 구현하는게 효율적임.
총알쪽에서 구현을 하려면 누가 맞았는지 일일히 조건문으로 체크해야함.
하여간 총알사라지는 스크립트 만들어서 벽쪽에 적용해줘야하는데
총알 오브젝트에 태그를 하나 만들어준다.
충돌 정보 객체를 받아와서 태그를 확인후에 제거하면 됨.

%
비교태그명 == collider.tag 이런식으로 비교해도 되지만
collision.collider.CompareTag(비교태그명) 이게 좀더 좋다

윗방식은 객체의 자체 비교 함수인 CompareTo 를 사용해서 정수값을 비교하지만
아랫방식은 문자 자체를 비교하기때문에 조금더 성능이 빠르다


% 객체를 연결하는 법
정적 연결 : 스크립트에서 public 변수를 설정해두고 인스펙터 창에서 연결
동적 연결 : 스크립트 start() 함수에서 GetComponent 로 연결


# 에셋에서 파티클 팩 적용해서

각종 파티클 적용해보기

1. 탄피 파티클
애니메이션 처럼 일정시간동안 떨어지는 애니메이션이다

# Particle System 컴포넌트
유니티에서는 파티클 시스템이 굉장히 잘되어있다.
유니티 공식튜토리얼에도 잘나와있으니 한번 보자

## Duration : 애니메이션 시간
## Start Lifetime : 객체 유지 시간
## Start Size : 사이즈 조절

## Collision 충돌 관련 설정
- Type : World
- Dampen : 0.1
- Bounce : 0.4
- Radius Scale : 0.1


2. 사격 효과 muzzle effect
FirePos 객체 자식으로 프리펩 넣어주고 실행해보면 잘됨.



3. 벽에 총알 부딪힌 자국 만들기

ContackPoint a = collision.contacts[0]; // 0번째가 제일 먼저 충돌한 위치

% LookAt 트랜스폼클래스가 갖고있는 함수 : Z축 좌표를 딱 돌린다
% LookRotation 쿼터니언클래스가 갖고있는 함수 : 객체의 정면과 지정된 위치 사이의 각도의 값을 구함
% FromToRotation 쿼터니언 : 지정된 각도와 지정된 각도 사이의 값을 구함 (최대 회전 각도가 180도)

% 충돌한 지점의 포인트값의 방향이 안쪽 수직방향으로 간다.
따라서 forward 가 아니라 - 방향으로 해줘야함 (back으론 보통 안함)
private void ShowEffect(Collision collision)
{
	ContactPoint contact = collision.contacts[0];
	Quaternion rotation = Quaternion.FromToRotation(-Vector3.forward, contact.normal);
	Instantiate(sparkEffect, contact.point, rotation);
}







초당10발로 나가게 하기

