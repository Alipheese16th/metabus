
교수님이 주신 에셋들 활용
https://drive.google.com/drive/folders/1B_1l1-YNYYJOf7GBlTvICBPzR7TXZaXs


유니티 예전버전은 에셋스토어가 유니티 안에 내장되어있지만
최신버전은 이제 브라우저로만 사용한다

에셋스토어에서 추가로 에셋 다운받자


복기하자면 유니티의 한칸은 1미터다.
Plane 을 하나 만들면 큰 한칸씩 차지하는데 (작은10칸 = 큰1칸) 각 10미터임


블렌더나 맥스에서 모델을 작업해서 fbx 파일로 저장하여 유니티로 불러오면
모델데이터를 import할때 유니티에서 그대로 들어오지않는다.
폴리곤은 vertex 로 정의되는데 이 버텍스 정보들로 불러오는것이다.
fbx파일은 버텍스정보들로만 구성되는것인데, 점과 점 사이의 정보도 가지고 있다.
점과 점 사이의 세그먼트 선
선과 선 사이의 면
면과 텍스쳐가 매핑이 된다.


#
Scene 뷰에서 디스플레이를 각각 보면
쉐이디드나 와이어프레임은 안봐도 아는거고

## Shadow Cascade
그림자 디테일 차이 확인

카메라로부터 일정 반경 영역을 그림자 디테일 차이

## Render Paths
렌더모드 차이 확인

렌더러가 어떤 셰이더를 이용해서 렌더링을 하는지
렌더방식마다 색깔의 차이로 보여줌

###
Forward Shading : 황색
일반적인 렌더링. 빛의 수가 일정 수를 넘어가면 비정교함
렌더링 파이프라인을 1번만 거침. (Vertex Shader, Rasterizer, Pixel Shader..)
'광원 갯수 X 메시 갯수' 의 드로우콜(Draw Call)이 발생한다.
광원이 늘어날수록 드로우콜이 기하급수적으로 증가한다.

###
Deferred Lighting : 녹색
1. 깊이와 노멀 정보에 대한 GBuffer를 통해 씬을 렌더링
2. 각 광원이 영향을 끼치는 픽셀을 찾아 해당 GBuffer 데이터를 읽은후 조명값을 계산해 밝기를 합산하는 렌더링 타겟에 저장
3. 마지막으로 합산된 밝기와 메시의 색을 결합해서 최종 픽셀 색상 계산

###
Defeered Shading : 청색
1. GBuffer에 렌더링 하되 후처리(포스트프로세싱)에 필요한 정보를 담는다.
2. 각 광원이 영향을 끼치는 픽셀을 찾아 해당 GBuffer데이터를 읽은후 픽셀의 조명색상을 계산해 중첩 버퍼에 저장한다.

Deferred 방식의 장단점
: Forward 쉐이딩에 비해 라이팅 연산이 엄청나게 줄어든다. 첫번째 파이프라인때 픽셀당 라이트계산을 미리 하기때문. 단 메모리도 더먹고 투명한 오브젝트의 렌더링이 불가능한 등 여러 단점도 있음
* 그러나 먼저 불투명 객체를 디퍼드로 그린후, 반투명 객체를 포워드 방식으로 그리면 해결 가능


###
Vertex Lit : 적색
가볍고 빠름 / 품질 낮음



## Alpha Channel
투명 오브젝트 확인

흰색은 불투명, 검정은 투명

## Overdraw
렌더링 최적화 확인

오브젝트의 겹친정도를 빨간색의 농도로 보여준다

% 오클루전 컬링
카메라로 보이는부분만 렌더링한다

## Mipmaps
텍스쳐 최적화
텍스쳐는 평면이미지이다. 텍스쳐의 해상도에 따라 용량의 차이가 심하다.
밉맵은 텍스쳐 해상도가 최적화가 잘되어있는지 확인할수있다.
텍스쳐가 뭉개져보일정도로 해상도가 낮으면 파랗게 보인다.
반대로 텍스쳐가 너무 고화질이면 빨갛게 보인다

% LOD 
거리에 따라 텍스쳐 정밀도가 달라지는 옵션
LOD그룹에 여러 오브젝트매쉬를 등록해서 카메라 거리에 따라 달리 적용시킨다



# 왼손좌표계
엄지가 오른쪽 X
검지가 위쪽 Y
중지가 앞쪽 Z
손가락을 마주보고 시계방향이 회전 +양방향


# Material

예시로 바닥 텍스쳐를 하나 입힌다. 바닥을 생성.

## tiling 타일링
수치를 조절하여 텍스쳐를 반복을 시키거나 확대를 할수 있다

##
노말맵 : 버텍스의 방향을 조절
Normal Map 텍스쳐도 입히면
조명에 따라 입체감이 더 보여진다.
노말맵 수치도 조절가능


# Prefabs
하나 만들어두면 해당 프리펩으로 만든 모든 오브젝트는 전부 적용됨.
일일히 하나 수정할때마다 다 수정할필요없음

프리펩을 만드는 방법은 그냥 오브젝트를 에셋 내에 이동시키면 알아서 적용됨.
에셋의 모델이 원본데이터임


# 좌표
Y 녹색좌표를 누르면 TOP 뷰로 된다.
TOP을 마우스로 누르면 원근감 없는 탑뷰로 변함


# 안티 알리어싱
벽을 4방향으로 딱 맞춰서 (모서리에 V 로 마우스로 움직이면 모서리끼리 딱 맞춤)
그림자와 다른 색상간의 반투명영역이 겹쳐서 생기는 현상


# skybox와 skydom
하늘을 표현할때 박스형식으로 표현
정육면체는 이미지를 6장을 써서 배치값이 너무 늘어남. (성능에서 불리)
돔형태로 구 형태로 표현하는건 스카이돔. 이건 이미지 1장이면 됨
단 요새는 스카이박스도 큐브맵(주사위도면처럼) 한장으로 처리해서 요즘은 다 스카이박스만 씀
파노라믹 스카이박스 : 철권같은 게임은 카메라가 고정되어 있어 위아래가 필요없기때문에 원기둥 형태로만 나타남

# Batches
이미지 하나 불러올때마다 한개씩 늘어남.
이 배치값에 따라 프레임수가 요동칠수 있음.

# 렌더링영역
카메라에서 일정거리만큼만 렌더링하게 만들면
너무 멀리 있는 개체는 렌더링안해도됨. 성능 최적화
너무 멀어서 안보일정도면 렌더링 안하게 하기.

단 이러한 방식으로 거리별 렌더링제한을 두면 하늘은 절대 렌더링될리가 없음.
그래서 하늘같은 스카이박스는 스크린스페이스에서 렌더링됨.

월드스페이스 메모리영역은 일반적인 가상공간의 오브젝트들이 렌더링 되는 영역
스크린스페이스는 별도의공간. 월드스페이스와 메모리영역이 다름

크로마키를 생각하면 편하다. 카메라가 그려내는 별도의 영역이다


# Directional Light
빛의 방향만 조절해주는것.
이 방향을 조절하면 태양의 위치가 바뀜



# SkyBox 만들어보기
매터리얼 하나 만들어서 쉐이더를 Skybox/Procedural 로 선택
그리고 Window - Lighting 에서 내가 만든 Skybox 매터리얼을 적용시키고
태양을 맘대로 설정할수있다
Quality : 태양 퀄리티 조절
Sun Size : 태양 크기 조절
Atmosphere Thickness : 하늘의 조명농도 조절


이제 다시 만들어서 
Shader를 Skybox/6 Sided 로 설정하고
교수님이 주신 스카이박스 에셋의 6장 이미지를 각 방향에 적용시키면 배경이 완성된다







